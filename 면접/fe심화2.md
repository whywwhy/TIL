![프심이.png](attachment:2b74857b-6c75-4d8d-8c95-76a173888766:프심이.png)

### **SSR, SSG, ISR의 차이점은 무엇인가요?**

**SSR (Server Side Rendering)**: 요청 시마다 서버에서 HTML을 생성해 전달합니다. 동적 데이터가 많을 때 적합하지만, 요청마다 렌더링하므로 성능 부담이 큽니다.

**SSG (Static Site Generation)**: 빌드 타임에 HTML을 생성해 정적 파일로 제공. 빠르고 효율적이지만, 실시간 데이터 반영이 어렵습니다.

**ISR (Incremental Static Regeneration)**: Next.js에서 제공. SSG 기반이지만, 특정 주기마다 페이지를 재생성해 최신 데이터를 제공합니다.

- SSR에서 FCP가 느려지는 이유는 무엇인가요? 
→서버에서 HTML을 생성해 보내는 동안 브라우저는 기다려야 하므로 초기 로딩 속도(FCP)가 느릴 수 있습니다.

### **WeakMap과 Map의 차이점은?**

Map: 키-값 쌍을 저장, 키로 객체뿐 아니라 원시값도 사용 가능. 반복 가능(iterable)합니다.

WeakMap: 키는 오직 객체만 가능하며, 가비지 컬렉션에 영향을 받기 때문에 참조가 없으면 자동으로 메모리에서 제거됩니다. 반복 불가.

- 왜 WeakMap은 반복이 안 될까요? 
→가비지 컬렉션과의 연동 때문에 내부 키를 추적할 수 없도록 설계되었습니다.

### **ES6의 주요 변화점은 무엇인가요?**

1. let, const로 블록 스코프 변수 선언 가능
2. 화살표 함수
3. 템플릿 리터럴
4. 디스트럭처링
5. 클래스 문법
6. 모듈 시스템 (import/export)
7. Promise
8. Rest/Spread 연산자
9. Map, Set, Symbol
- var와 let의 차이점은? 
→ var는 함수 스코프, let은 블록 스코프입니다. 또한 let은 중복 선언 불가입니다.

### **png, jpg, svg 등의 이미지 포맷 차이점은?**

1. **JPG**: 손실 압축, 사진 등에 적합
2. **PNG**: 무손실 압축, 투명도 지원
3. **SVG**: 벡터 기반, 확대해도 깨지지 않음. 아이콘, 로고 등에 적합
4. **WEBP**: 구글에서 만든 포맷, 작은 용량에 고화질 지원
- 웹 성능 최적화를 위해 어떤 이미지 포맷을 선택하시나요?
→ 웹 성능을 고려해 SVG (벡터)나 WebP (고압축)을 선호합니다.

### **브라우저의 렌더링 과정은 어떻게 되나요?**

1. HTML 파싱 → DOM 트리 생성
2. CSS 파싱 → CSSOM 생성
3. DOM + CSSOM → 렌더 트리
4. 렌더 트리 Layout → 위치 계산
5. Paint → 픽셀로 변환
6. Composite → 화면에 렌더링
- DOM 변경이 Reflow와 Repaint에 어떤 영향을 미치나요?
→ DOM의 구조 변경은 Reflow를 유발하고, 시각적 스타일 변경은 Repaint만 발생시킵니다.

### **Reflow와 Repaint는 언제 실행되나요?**

1. **Reflow**: 레이아웃 계산이 필요한 경우 (예: 크기, 위치 변경)
2. **Repaint**: 스타일만 바뀐 경우 (예: 색상 변경)
- Reflow를 최소화하는 방법은?
→ DOM 변경을 최소화하거나 display: none 후 배치 변경, requestAnimationFrame 사용 등.

### **HTTP와 HTTPS의 차이는 무엇인가요?**

1. HTTPS는 HTTP에 SSL/TLS 암호화가 추가되어 데이터 보안이 강화됨
2. 데이터를 암호화하여 중간자 공격(MITM)을 방지
- SSL 인증서는 어떤 역할을 하나요?
→ 서버가 신뢰할 수 있음을 보장하며, 클라이언트와 서버 간 통신을 암호화합니다.

### **브라우저는 어떻게 동작하나요?**

1. URL 입력 → DNS 조회 → 요청 전송 → 서버 응답 → HTML 파싱 → 렌더링 → 사용자에게 보여짐
2. 이 과정에서 렌더링 엔진, JS 엔진, 네트워크 스택 등이 협력

### **Webpack, Babel, Polyfill 설명**

1. **Webpack**: 모듈 번들러. JS, CSS, 이미지 등을 하나의 파일로 번들링
2. **Babel**: ES6+ 코드를 하위 브라우저에서 동작하도록 트랜스파일링
3. **Polyfill**: 브라우저가 지원하지 않는 기능을 대신 구현하는 코드
- Babel 없이 ES6 코드를 쓸 수 있을까요?
→ 최신 브라우저만 지원한다면 가능하지만, 브라우저 호환성을 위해 Babel이 필요합니다.

### **ESLint와 Prettier 설명**

1. **ESLint**: 코드 문법과 스타일 오류를 탐지하고 규칙에 따라 검사
2. **Prettier**: 코드 포매터. 일관된 코드 스타일 유지
- 두 도구를 함께 쓰는 이유는?
→ Prettier로 스타일 통일, ESLint로 코드 품질 유지 → 협업에 매우 유용합니다.

### **SPA와 MPA의 차이는 무엇인가요?**

1. **SPA**: 단일 HTML로 구성, 라우팅은 클라이언트에서 수행
2. **MPA**: 페이지 이동마다 새로운 HTML 요청, 서버 렌더링 기반
- SPA의 SEO 문제는 어떻게 해결하나요?
→ SSR 또는 메타태그 설정, pre-rendering, dynamic sitemap 등을 활용합니다.

### **CSR과 SSR의 차이는 무엇인가요?**

1. **CSR (Client Side Rendering)**: HTML을 받아온 후 JS로 렌더링
2. **SSR (Server Side Rendering)**: 서버에서 HTML을 생성해서 클라이언트에 전달
- SEO가 중요한 페이지는 어떤 방식을 선택해야 하나요?
→ SSR이 적합합니다. 크롤러가 HTML을 바로 읽을 수 있으니까요.

### **CORS란 무엇이고, 해결 경험이 있나요?**

**CORS**: 브라우저 보안 정책으로, 다른 도메인 간 요청을 제한

서버가 Access-Control-Allow-Origin 헤더를 명시해야 함

**해결 경험**: 프록시 서버를 사용하거나, 서버 측에서 CORS 헤더 설정으로 해결

- Credential 포함 요청에서 주의할 점은?
→ withCredentials: true와 서버의 Access-Control-Allow-Credentials: true 모두 설정 필요

### **번들 사이즈를 줄이기 위한 방법은?**

1. 코드 스플리팅 (Code Splitting)
2. Tree Shaking
3. Lazy Loading
4. 이미지 압축
5. 경량 라이브러리 사용
6. 외부 CDN 활용
- Tree Shaking이 작동하지 않을 수 있는 경우는?
→ CommonJS 모듈(CJS)을 사용할 경우, 정적 분석이 어려워 Tree Shaking이 작동하지 않을 수 있습니다.

### **쿠키, 세션, 웹 스토리지 차이점은?**

| **구분** | **쿠키** | **세션** | **웹스토리지 (local/session)** |
| --- | --- | --- | --- |
| 저장 위치 | 클라이언트 | 서버 | 클라이언트 |
| 만료 시점 | 설정 가능 | 브라우저 종료 시 | 직접 설정 or 세션 중 유지 |
| 용량 제한 | 약 4KB | 제한 없음 | 약 5~10MB |
| 용도 | 인증 정보 | 로그인 상태 유지 | 사용자 데이터 저장 |

### **로그인 처리를 할 때 쿠키와 세션을 어떻게 사용하시나요?**

로그인 성공 시, 서버에서 세션 ID를 발급하고 이를 쿠키에 저장해 클라이언트로 전달

이후 요청마다 쿠키로 세션 확인 → 사용자 인증 유지

- 보안을 강화하기 위한 쿠키 설정은?
→ HttpOnly, Secure, SameSite=Strict 속성을 설정하여 XSS, CSRF를 방지할 수 있습니다.