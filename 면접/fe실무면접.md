![프실무.png](attachment:1d53d551-43b0-43f2-9691-ec9e5d83ed11:프실무.png)

### 1. 어떤 프레임워크를 사용하여 개발하였나요? 왜 그 프레임워크를 선택했나요?

저는 React를 선호합니다. 이유는 React가 사용자 인터페이스 구축과 관리를 쉽게 할 수 있는 사용자 측 라이브러리이기 때문입니다. 또한, 리액트 컴포넌트는 모듈화를 통해서 개발 생산성을 높이고, 코드 유지 보수성을 높일 수 있습니다.
**-> 여기서 React를 통해서 어떤 장점을 활용할 수 있는지 조금 더 준비**

### 2. RESTful API에 대해 설명해주세요

RESTful API는 HTTP 프로토콜을 기반으로하는 웹 서비스 아키텍처입니다. 자원, 메소드, 메시지 등을 정의하여 클라이언트-서버 간의 통신을 가능하게 합니다. 또한, RESTful API는 표준 HTTP 메소드(GET, POST, PUT, DELETE)를 사용하여 서버와 통신합니다
**-> 이 질문을 대답하면서, HTTP 메소드에 대한 사용 방법에 대해서도 꼬리물기 질문이 들어올 수 있으니 준비하시는 것이 중요**

### 3. **그렇다면 HTTP 메소드에 대한 설명도 해주실 수 있나요?**

GET: 서버에서 리소스(데이터)를 요청하는 메소드입니다. 요청한 데이터를 가져와 응답합니다.
POST: 서버에 데이터를 전송하는 메소드입니다. 데이터를 전송하여 서버에서 처리하고, 처리 결과를 응답합니다.
PUT: 서버에 데이터를 업데이트하는 메소드입니다. 요청한 데이터를 서버에 저장하고, 처리 결과를 응답합니다.
DELETE: 서버에서 데이터를 삭제하는 메소드입니다. 요청한 데이터를 서버에서 삭제하고, 처리 결과를 응답합니다.
**-> 간략하게 기능 별 포인트를 함축적으로 이야기하는 것이 중요**

- HTTP
    
    HTTP 메소드는 클라이언트(예: 브라우저)가 서버에게 특정 작업을 요청할 때 사용하는 방식입니다.. 각각의 메소드는 용도가 다르고, 주로 REST API에서 많이 사용됩니다.
    
    | **메소드** | **설명** | **주로 사용하는 상황** |
    | --- | --- | --- |
    | GET | 데이터를 **조회**할 때 사용 | 게시글 목록 조회, 유저 정보 가져오기 등 |
    | POST | 데이터를 **생성**할 때 사용 | 회원가입, 새 게시글 등록 등 |
    | PUT | 데이터를 **전체 수정**할 때 사용 | 게시글 전체 내용 수정 등 |
    | PATCH | 데이터를 **부분 수정**할 때 사용 | 닉네임만 수정, 비밀번호만 변경 등 |
    | DELETE | 데이터를 **삭제**할 때 사용 | 게시글 삭제, 계정 탈퇴 등 |
    - GET과 DELETE는 일반적으로 **본문(body)**을 사용하지 XX
    - POST, PUT, PATCH는 **본문에 JSON 데이터**를 담아 전송하는 경우가 많습니다.
    - 보안이 필요한 경우 https를 사용하고, 인증이 필요한 경우 토큰 등도 함께 전송해야 합니다.

### 4. **CSRF나 XSS 공격을 막는 방법은?**

CSRF 공격을 막기 위해서는 서버에서 CSRF Token을 생성하여 세션에 저장하고, 프론트엔드에서 요청 시 해당 Token을 함께 전송하여 인증합니다. SameSite 속성을 쿠키에 설정하여 도메인이 다른 사이트에서는 쿠키를 사용할 수 없도록 제한하는 방법도 있습니다. 
XSS 공격을 막기 위해서는 입력 값들을 유효성 검증하고, 특수문자들을 제외하는 정규식을 통해서 제거합니다. 또, 서버에서 CSP(Content-Security-Policy)정책을 설정하여, 허용된 스크립트만 실행되도록 제한 할 수도 있습니다. 마지막으로, HTTP 대신에 신뢰할 수 있는 HTTPS를 사용하여 통신 프로토콜을 암호화할 수 있습니다.

- CSRF / XSS
    
    
    | **공격** | **방어 방법 요약** |
    | --- | --- |
    | **CSRF** | CSRF 토큰, SameSite 쿠키, Referer 체크 |
    | **XSS** | 입력값 검증, 출력 escape, CSP, HttpOnly 쿠키 |
    
    **CSRF**(Cross-Site Request Forgery)와 **XSS**(Cross-Site Scripting)는 대표적인 보안 위협입니다.
    
    1.  **CSRF (사이트 간 요청 위조)**
    사용자가 **의도하지 않은 요청**을 하도록 유도해 피해를 입히는 공격입니다.
    - **CSRF 토큰 사용**
        - 서버가 랜덤한 **토큰**을 발급하고, 클라이언트는 요청 시 이 토큰을 함께 보냄.
        - 서버는 토큰이 유효한지 확인해 요청을 허용함.
        
        ```
        <input type="hidden" name="csrfToken" value="서버가 발급한 토큰">
        ```
        
    - **SameSite 쿠키 설정**
        - 쿠키에 SameSite 속성을 부여하면, **다른 사이트에서의 요청에 쿠키가 전송되지 않도록** 할 수 있습니다.
        
        ```
        Set-Cookie: sessionId=abc123; SameSite=Strict
        ```
        
    - **Referer 검사**
        - 요청의 Referer 헤더를 확인해 **신뢰할 수 있는 출처인지 확인**할 수 있습니다. (완벽하지는 않음).
    1. **XSS (크로스 사이트 스크립팅)**
    사용자가 입력한 데이터를 검증하지 않고 웹페이지에 노출했을 때, 악성 스크립트가 실행되는 공격입니다.
    - **입력값 필터링 & 검증**
        - 사용자 입력에서 **스크립트, 태그, 특수문자**를 제거하거나 제한해야 합니다.
        
        ```
        const clean = input.replace(/</g, "&lt;").replace(/>/g, "&gt;");
        ```
        
    - **출력 시 이스케이프**
        - HTML, JS, URL 등 **출력 위치에 따라 적절히 이스케이프** 처리하기
        - 예: React는 JSX 내부에서 자동으로 escape 해줌
        
        ```
        <p>{userInput}</p> // React는 자동 escape 처리함
        ```
        
    - **Content Security Policy(CSP) 사용**
        - 스크립트 실행 범위를 제한해 XSS를 막을 수 있음
        
        ```
        Content-Security-Policy: default-src 'self'; script-src 'self'
        ```
        
    - **HTTPOnly & Secure 쿠키 사용**
        - XSS로 쿠키 탈취를 방지하려면 HttpOnly 속성을 설정해서 **자바스크립트에서 접근하지 못하게** 해야 합니다.
        
        ```
        Set-Cookie: sessionId=abc123; HttpOnly; Secure
        ```
        

### 5. **async/await에 대해 설명해보세요.**

async/await는 비동기적인 작업을 처리할 수 있는 ES2017 문법 입니다. 
async 함수를 정의하면 함수 내부에서 await 키워드를 이용하여 비동기적으로 처리되는 작업이 완료될 때까지 기다린 후, 결과값을 반환하는 처리를 할 수 있습니다. 
async/await는 Promise를 기반으로 하며, 코드를 보다 간결하고 직관적으로 작성할 수 있도록 해줍니다. async 함수는 항상 Promise 객체를 반환하며, await 키워드를 이용하여 비동기 처리 결과를 기다립니다.
**-> 비동기 함수이며, 비동기가 어떤 뜻인지도 설명할 준비가 되어야함**

- 비동기
    
    **비동기란?**
    
    일반적으로 코드는 **위에서 아래로 차례대로 실행**되는데,
    
    비동기는 **시간이 오래 걸리는 작업(예: 서버 요청, 파일 읽기 등)을 기다리지 않고 다음 코드로 넘어가는 방식입니다.** 
    
    **async/await란?**
    
    자바스크립트에서 비동기 처리를 쉽게 하기 위해 도입된 **Promise 기반 문법**
    
    | **키워드** | **설명** |
    | --- | --- |
    | async | 함수를 비동기로 만들어줌. 항상 **Promise**를 반환 |
    | await | Promise가 **해결(resolve)될 때까지 기다림** |
    
    **기존 방식: Promise 체이닝**
    
    ```
    function getData() {
      return fetch('https://api.example.com/data')
        .then(res => res.json())
        .then(data => console.log(data))
        .catch(err => console.error(err));
    }
    ```
    
    ---
    
    **async/await 방식**
    
    ```
    async function getData() {
      try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        console.log(data);
      } catch (err) {
        console.error(err);
      }
    }
    ```
    
    훨씬 **가독성 좋고**, 에러 처리도 try/catch로 깔끔합니다. 
    
    - await은 **async 함수 안에서만 사용 가능**
    - await은 **Promise가 끝날 때까지 기다림**
    - async 함수는 항상 **Promise를 반환**함
    
    **언제 사용?**
    
    - API 호출, DB 요청, 파일 읽기 등 **시간이 걸리는 작업**
    - 여러 개의 비동기 작업을 **순서대로 처리하고 싶을 때**
    - 콜백 지옥이나 .then() 체이닝을 **간단하게 바꾸고 싶을 때**

### 6. **브라우저 렌더링 원리에 대해서 설명해보세요.**

브라우저 렌더링은 HTML, CSS, JavaScript 등의 웹 페이지 자원을 브라우저가 화면에 그리는 과정을 말합니다. 
브라우저 렌더링 원리와 순서는 크게 다음과 같은 단계로 구성됩니다.
먼저 DOM을 생성합니다. 브라우저는 HTML 문서를 파싱하여 DOM 트리를 생성합니다. 이때, HTML 태그를 노드로 변환하고, 노드간의 계층 관계를 형성합니다.
두 번째로 CSSOM을 생성합니다. 브라우저는 CSS 파일을 파싱하여 CSSOM 트리를 생성합니다. 이때, CSS 속성을 노드로 변환하고, 노드간의 계층 관계를 형성합니다.
세 번째로 DOM트리와 CSSOM을 결합하여 렌더 트리를 생성 합니다. 이때, 실제 화면에 표시될 요소만을 선택하여 렌더 트리를 형성합니다.
이제, 브라우저는 렌더 트리를 이용하여 각 요소의 크기와 위치를 계산하는 과정인 레이아웃을 거쳐 화면에 요소를 그리는 페인팅 과정을 거치게 됩니다. 이때, 요소의 배경, 테두리, 글자 등을 그리게 됩니다.
**-> 전체적인 과정을 머릿 속에 그려놓고, 꼭 위와 같이 설명하지 않아도 흐름을 대략적으로 설명하실 수 있다면 대답하셔도 충분할 것**

- CSSOM
    
    **CSSOM이란?**
    
    CSSOM은 **“CSS Object Model”**의 줄임말입니다.
    HTML을 브라우저가 파싱하면 DOM(Document Object Model)을 만들듯, CSS도 파싱되어 **CSSOM**이라는 **객체 트리 구조**로 변환됩니다.
    
    → 이 CSSOM과 DOM이 결합돼서 **렌더 트리(Render Tree)**가 만들어지고
    
    → 최종적으로 웹페이지가 렌더링
    

### **7. 가장 최근에 해결한 기술적인 문제는 무엇이었나요?**

최근에는 프로젝트에서 발생한 성능 이슈를 해결하는 문제를 해결했습니다. 문제 해결을 위해 코드를 리팩토링하고, 불필요한 부분들을 최적화하여 크롬 LightHouse를 통해 높은 점수를 받을 수 있었습니다.
**-> 본인이 프로젝트에서 직접적으로 개선한 부분들. 평소에 리팩토링 습관이 있으시다면 대답하시기 수월할 것**

### 8. ~~ **해당 프로젝트에서 자신의 역할은 무엇이었나요?**

프로젝트 초기에는 요구사항 분석과 설계 단계에 참여해서 와이어프레임을 팀원들과 함께 제작 하였습니다. 이후 개발 단계에서는 주로 지도 카테고리를 맡았으며, 프로젝트 종료 후에는 유지 보수와 최적화를 진행 하였습니다.
**-> 본인이 협업 프로젝트를 한 경험이 무조건 있으면 대답할 수 있는 좋은 상황. 회사는 협업하는 공간이기 때문에 매우 중요한 부분.**

### 9. **호이스팅에 대해 설명해보세요.**

호이스팅은 변수와 함수 선언이 스코프(scope)의 최상단으로 올려져 실행되는 것을 의미합니다. 이로 인해 선언 전에 사용하는 경우 오류가 발생할 수 있습니다.

- 스코프
    
    **스코프(Scope)**는 프로그래밍에서 **“변수에 접근할 수 있는 범위”**를 의미
    
    | **종류** | **설명** |
    | --- | --- |
    | **전역 스코프** | 코드 어디서든 접근 가능 (예: 함수 밖에서 선언한 변수) |
    | **지역 스코프** | 특정 함수, 블록 {} 내부에서만 접근 가능 |
    | **블록 스코프 (ES6 이후)** | let, const는 {} 블록 내부에만 유효해요 |
    | **함수 스코프** | var는 오직 함수 내부에만 유효 (블록은 무시) |
    
    **스코프 체인**
    
    변수를 찾을 때 **현재 스코프 → 바깥쪽 → 전역** 순으로 찾아갑니다.
    
    **→ 왜 중요한가?**
    
    - **변수 충돌 방지**: 같은 이름의 변수라도 다른 스코프에 있으면 문제 없이 공존 가능
    - **메모리 관리**: 함수가 끝나면 그 안의 변수는 사라짐

### 10. **"==" 와 "==="의 차이는 무엇인가요?**

"=="는 동등 연산자로, 두 값을 비교할 때 형변환(type coercion)을 수행합니다. 즉, 비교하는 값의 데이터 타입이 다르더라도 자동으로 형변환을 수행한 후에 비교합니다. 이러한 형변환은 때로 예측하지 못한 결과를 초래할 수 있으므로, "=="를 사용할 때는 조심해야 합니다. "==="는 일치 연산자로, 두 값이 데이터 타입과 값이 모두 같은지 비교합니다. 따라서 "==="를 사용하면 형변환 없이 정확한 값을 비교할 수 있습니다. 이러한 일치 연산자를 사용하는 것이 더 안전하고 예측 가능한 결과를 얻을 수 있습니다.

### 11. **클로저란 무엇인가요?**

함수가 선언될 때 자동으로 생성되는 렉시컬 환경에 대한 설명입니다. 이러한 렉시컬 환경은 스코프 체인(scope chain)을 형성하게 되는데, 스코프 체인은 함수가 선언될 때의 모든 변수와 함수를 포함하는 렉시컬 스코프(lexical scope)를 형성합니다. 외부 함수가 실행 되고 반환된 후에도 외부 함수의 범위 내의 함수에 체이닝을 할 수 있는 함수 입니다. 정보를 은닉하기 위해서 주로 사용 합니다.
**-> 매우 중요한 개념!!!!!**

![](https://storage.googleapis.com/static.fastcampus.co.kr/prod/uploads/202303/235736-934/%ED%81%B4%EB%A1%9C%EC%A0%80.png)

- **> outer는 inner를 return. innerExecute에는 outer에서 반환한 inner함수가 할당되게 됩니다. innerExecute를 호출할 때마다, outer에서 정의한 outerVal을 출력하게 됩니다. 이때 inner 함수는 outer 함수의 스코프 체인을 유지하게 되는데, 이러한 특성을 이용하여 클로저를 구현한 것입니다.**
- 클로저
    
    **클로저는 함수가 선언될 당시의 외부 변수(스코프)를 기억하고,**
    
    **그 함수가 외부에서 실행되더라도 그 기억된 스코프에 접근할 수 있는 기능이에요.
    
    왜 중요한가?** 
    
    - **변수를 은닉**할 수 있고
    - **함수형 프로그래밍**이나 **콜백 함수**, **이벤트 핸들러**, **setTimeout** 등에서 자주 사용
    - **상태 유지**
    
    | **개념** | **설명** |
    | --- | --- |
    | 정의 | 함수가 외부 변수(스코프)를 기억하고 참조할 수 있는 기능 |
    | 특징 | 함수가 선언될 당시의 환경을 기억함 |
    | 장점 | 상태 유지, 정보 은닉 등 |
    
    사용 예시 
    
    - **React Hook** 내부
    - **이벤트 핸들러**
    - **타이머**
    - **모듈 패턴**
    - **setTimeout / setInterval**
    - **콜백 함수가 외부 값을 사용할 때**

### 12. **클래스형 컴포넌트와 함수형 컴포넌트의 차이는 무엇일까요?**

리액트에서 컴포넌트를 만드는 방법에는 클래스형 컴포넌트(class components)와 함수형 컴포넌트(functional components)가 있습니다. 클래스형 컴포넌트는 ES6의 클래스(class)를 사용하여 컴포넌트를 정의합니다. 이 방식은 React의 컴포넌트의 상태(state)와 생명주기(lifecycle)를 다룰 때 매우 유용합니다.반면에 함수형 컴포넌트는 ES6의 화살표 함수(arrow function)를 사용하여 컴포넌트를 정의합니다. 이 방식은 훅(hook) API와 함께 많이 사용되며, 컴포넌트의 상태와 생명주기를 다룰 때도 유용합니다.클래스형 컴포넌트와 함수형 컴포넌트의 가장 큰 차이점은 상태와 생명주기의 다루는 방식입니다. 클래스형 컴포넌트는 상태를 this.state로 정의하고, 생명주기 메서드를 오버라이드하여 다양한 작업을 수행합니다. 반면에 함수형 컴포넌트는 상태를 useState 훅을 사용하여 정의하고, useEffect 훅을 사용하여 생명주기를 다룹니다. 또한, 클래스형 컴포넌트에서는 this 키워드를 사용하여 상태나 메서드를 참조하며, 함수형 컴포넌트에서는 this 키워드를 사용하지 않습니다. 이러한 차이점 때문에, 함수형 컴포넌트는 더 간결하고 가독성이 좋아지며, 테스트와 리팩토링이 쉽게 이루어질 수 있습니다.
**-> 차이점에 대해 인지 하고 있기!**

### 13.  **이벤트 버블링에 대해서 설명해주세요.**

이벤트 버블링(event bubbling)은 HTML에서 이벤트가 발생했을 때, 해당 요소에서 이벤트가 처리된 후, 상위 요소로 이벤트가 전파되는 현상을 말합니다. 이벤트 버블링은 이벤트가 전파되는 동안 부모 요소에서도 이벤트를 감지할 수 있다는 장점이 있습니다. 즉, 이벤트를 처리하는 핸들러 함수를 부모 요소에 등록해놓으면, 자식 요소에서 발생한 이벤트도 모두 처리할 수 있습니다. 이를 활용하면, 여러 개의 하위 요소에서 발생하는 이벤트를 하나의 이벤트 핸들러로 바인딩하는 이벤트 위임 처리를 할 수 있습니다. 버블링 및 캡쳐링을 방지하기 위해서는 이벤트 객체의 stopPropagation() 메서드를 사용하여 이벤트 전파를 중지시키거나, 이벤트 핸들러에서 이벤트가 발생한 요소를 확인하여 처리해야 합니다.
**-> 이벤트 버블링과 캡쳐링의 차이점에 대해서 구분해서
->이벤트 위임에 대해서도**

- 이벤트 버블링 & 이벤트 캡쳐링
    
    **이벤트 버블링(Event Bubbling)**과 **이벤트 캡쳐링(Event Capturing)**은 **DOM에서 이벤트가 전파되는 방식**
    
    | **구분** | **이벤트 캡쳐링 (Capturing)** | **이벤트 버블링 (Bubbling)** |
    | --- | --- | --- |
    | 순서 | **부모 → 자식** | **자식 → 부모** |
    | 실행 시점 | 이벤트 **전파 초반** | 이벤트 **전파 후반** |
    | 기본 동작 | 기본적으로는 사용되지 않음 | 브라우저의 **기본 전파 방식** |
    | 등록 방식 | addEventListener('click', handler, **true**) | addEventListener('click', handler, **false**) |
    
    **이벤트 캡쳐링**: 부모 → 자식 방향으로 이벤트가 전파됨 (초기 단계)
    
    **이벤트 버블링**: 자식 → 부모 방향으로 이벤트가 전파됨 (기본 방식)
    
    - 기본적으로 addEventListener는 **버블링**을 사용함 (false)
    - true를 넣으면 **캡쳐링**으로 동작함
    
    ```
    DOM 구조:
    window
    └── document
        └── html
            └── body
                └── div#parent
                    └── button#child
    
    1. 캡쳐링: window → ... → child (자식 도착 전)
    2. 타겟: child (이벤트 발생)
    3. 버블링: child → ... → window (부모로 올라감)
    ```
    
- 이벤트 위임
    
    **여러 자식 요소들의 이벤트를 부모 하나에 위임**해서 처리하는 방식입니다.
    
    즉, 많은 자식 요소 각각에 이벤트를 따로 달지 않고, **공통된 부모 요소에만 이벤트 리스너를 달고**, 이벤트가 **버블링** 되는 특성을 이용해 처리하는 것
    
    **왜 쓸까?**
    
    | **이유** | **설명** |
    | --- | --- |
    | 성능 | 자식마다 이벤트 걸지 않아도 돼서 **가볍고 빠름** |
    | 동적 요소 대응 | 새로 생성된 요소에도 **자동으로 적용됨** |
    | 유지보수 쉬움 | 코드가 **간결하고 재사용성** 좋아짐 |
    
    **주의할 점**
    
    - event.target은 실제 클릭된 **자식 요소**
    - event.currentTarget은 이벤트가 달린 **부모 요소**
    - 스타일이나 구조에 따라 의도치 않게 **다른 요소 클릭으로 오작동할 수 있음**
    
    → 그래서 보통 조건문으로 event.target.matches() 또는 tagName 등을 체크합니다.
    

### 14. **스토리북에 대해서 아시나요?**

스토리북(Storybook)은 UI 컴포넌트 개발을 위한 도구로, 개별 컴포넌트의 기능과 상태를 다양한 시나리오로 테스트하고, 문서화하여 관리할 수 있는 환경을 제공합니다. 이를 통해 UI 개발자와 디자이너는 컴포넌트의 독립적인 테스트와 문서화를 통해 작업 효율성과 코드 품질을 향상시킬 수 있습니다.
**-> 최근 트렌드를 넘어 스테디하게 사용되고 있는 부분들도 함께 물어볼 수 있음**

### 15. TDD란 무엇인가요?

TDD(Test-Driven Development)는 테스트 주도 개발 방법론의 준말로, 개발자가 코드를 작성하기 전에 먼저 테스트 케이스를 작성하고 이를 통과시키는 것을 중심으로 개발을 진행하는 방법입니다. TDD는 코드 품질을 향상시키고 버그를 미리 발견하여 개선하는 데 도움이 됩니다. 또한, 코드 변경 시 이전에 작성된 테스트 케이스를 수행하여 기존 코드의 영향을 미치는 부분을 파악하고, 안정적인 코드 개발에 도움을 줍니다.
**-> TDD 도구인 Jest, Cypress, testing-library 등도 함께 알고있기**

- TDD
    
    TDD(테스트 주도 개발)를 실천하거나 테스트를 자동화할 때 자주 사용 
    
    **1. Jest – 유닛 테스트/통합 테스트용 JS 테스트 프레임워크**
    
    - Meta(구 Facebook)에서 만든 **자바스크립트 테스트 프레임워크**
    - **유닛 테스트**와 **통합 테스트**에 강함
    - React를 비롯한 다양한 프레임워크에서 널리 사용됨
    - create-react-app으로 프로젝트 생성 시 기본 포함
    
    | **장점** | **설명** |
    | --- | --- |
    | 빠름 | 자체 테스트 러너 내장 (설정 최소화) |
    | 다양한 매처 | toBe, toEqual, toThrow 등 직관적 |
    | Mock 기능 지원 | 함수나 모듈의 가짜 동작 테스트 가능 |
    | Snapshot 테스트 | UI 스냅샷을 비교해서 변화 감지 가능 |
    
    ---
    
    **2. Testing Library – React 컴포넌트 테스트에 특화된 라이브러리**
    
    - 실제 사용자처럼 **DOM을 조작**하고 **접근성 기준**으로 컴포넌트를 테스트
    - @testing-library/react가 대표적 (React 기반 테스트용)
    
    | **장점** | **설명** |
    | --- | --- |
    | 사용자 중심 테스트 | getByText, getByRole 등 실제 사용 행위 기반 |
    | Jest와 찰떡 | Jest와 함께 쓰는 게 일반적 |
    | 접근성 강화 | aria-label, 역할(Role) 기반 테스트에 강함 |
    | 모듈화 가능 | 다양한 DOM 유틸 제공 (form, 이벤트 등) |
    
    ---
    
    **3. Cypress – E2E(엔드 투 엔드) 테스트 자동화 도구**
    
    - **브라우저 기반의 UI 자동화 테스트 도구**
    - 사용자가 웹사이트를 이용하는 시나리오 전체를 테스트
    - 버튼 클릭, 폼 작성, 페이지 이동까지 흐름 테스트 가능
    
    | **장점** | **설명** |
    | --- | --- |
    | 실제 브라우저 동작 | 사용자 경험을 그대로 재현 |
    | 시각적 디버깅 가능 | 테스트 중의 화면 확인 가능 |
    | 자동 재시작 / 디버깅 편함 | 실시간으로 실패 원인 파악 |
    | REST API, 인증 시나리오도 가능 | 토큰/세션 기반 흐름도 테스트 가능 |
    
    ---
    
    | **항목** | **Jest** | **Testing Library** | **Cypress** |
    | --- | --- | --- | --- |
    | 주요 목적 | 유닛/로직 테스트 | UI 컴포넌트 테스트 | E2E 시나리오 전체 테스트 |
    | 테스트 범위 | 함수, 모듈 | 컴포넌트 (단위) | 전체 앱 흐름 |
    | 러닝 커브 | 쉬움 | 쉬움~중간 | 약간 있음 |
    | 실행 속도 | 빠름 | 빠름 | 상대적으로 느림 |
    | 사용자 기반? | ❌ (로직 중심) | ✅ | ✅ ✅ ✅ |
- TDD vs BDD
    
    **TDD (테스트 주도 개발)**
    
    **“개발 전에 먼저 테스트 코드를 작성”하는 개발 방식**
    
    1. **테스트 먼저 작성** (실패함 → Red)
    2. 테스트를 통과시키기 위한 **코드 작성** (통과 → Green)
    3. 코드 리팩토링 (중복 제거, 구조 개선 등)
    
    **Red → Green → Refactor** 사이클을 반복
    
    - **개발자가 테스트 시나리오 작성**
    - 작은 단위(함수, 모듈)의 로직 위주
    - 코드 품질 개선, 리팩토링에 유리
    
    ---
    
    **BDD (행위 주도 개발)**
    
    **“사용자의 행동(Behavior)을 기준으로 테스트를 작성”하는 개발 방식**
    
    비즈니스 요구사항(=기능)이 중심!
    
    1. **시나리오 기반의 행동 정의**
    2. 해당 시나리오가 만족되는지 테스트
    3. 개발자는 그 시나리오를 충족시키는 코드 작성
    
    ---
    
    **TDD vs BDD표**
    
    | **항목** | **TDD (테스트 주도 개발)** | **BDD (행위 주도 개발)** |
    | --- | --- | --- |
    | 테스트 작성자 | 개발자 중심 | 개발자 + 기획자/테스터 협업 |
    | 초점 | **로직, 함수** 중심 | **기능, 행동** 중심 |
    | 테스트 설명 | 기술적 | 자연어 기반, 사용자 관점 |
    | 예시 도구 | Jest, Mocha | Jest + Testing Library, Cypress, Cucumber |
    | 시나리오 문서화 | ❌ | ✅ (Gherkin 언어 등으로 작성 가능) |
    
    ---
    
    - **TDD**
    
    → 함수, 유틸, 내부 로직이 중요한 경우 (ex. 계산기, 정렬기능 등)
    
    - **BDD**
    
    → 사용자 행동 중심 기능이 많은 경우 (ex. 로그인, 글 작성, 쇼핑몰 결제 등)
    
- Cypress
    
    
    | **테스트 분류** | **Cypress는?** | **설명** |
    | --- | --- | --- |
    | ✅ E2E 테스트 | **주로 사용됨** | 실제 브라우저에서 사용자처럼 시나리오 실행 (로그인, 게시물 작성 등) |
    | ⭕ 통합 테스트 | **일부 가능** | API와의 상호작용 테스트 등 |
    | ⭕ BDD 스타일 | **가능** | describe, it 문법 사용하며 사용자 중심 시나리오 작성 가능 |
    | ❌ 유닛 테스트 | **비권장** | DOM 기반 UI 테스트에 더 적합. 로직 테스트는 다른 도구가 좋음 |

### 16. **Static Site Generator에 대해서 아시나요?**

Static Site Generator(SSG)는 정적인 HTML, CSS, JavaScript 파일을 생성하는 소프트웨어입니다. SSG를 사용하면 동적인 서버 측 프로그래밍 없이 정적인 웹 페이지를 생성할 수 있습니다. 이에 대한 몇 가지 장점은 다음과 같습니다. 정적인 파일을 생성하기 때문에, 웹 서버의 보안에 대한 걱정이 줄어듭니다. 정적인 파일은 웹 브라우저에 의해 더 빠르게 다운로드됩니다. 따라서 로딩 속도가 향상되며 사용자 경험이 좋아집니다. GatsbyJS, Next.js, Hugo, Jekyll 등과 같은 플랫폼들이 있습니다.
**-> 각각의 플랫폼들의 특징들에 대해서도 간략히 파악해놓기**

### 17. **Flex와 Grid의 차이점에 대해서 설명해보세요.**

Flex는 주로 단일 축 방향의 레이아웃을 구성하는 데 사용되며, 주로 수평 방향으로 레이아웃을 정렬합니다. Grid는 2차원 그리드 시스템을 구성하는 데 사용되며, 수평과 수직 방향으로 모두 레이아웃을 정렬할 수 있습니다. Flex는 아이템들의 크기가 자유로워 유동적으로 변할 수 있습니다. 반면에 Grid는 아이템들의 크기를 미리 정의하여 각 셀의 크기를 일정하게 유지합니다. Flex는 유동적인 레이아웃 변화를 구성하기 적합합니다. 반면에 Grid는 미리 정의된 2차원 그리드 구조를 유지하기 때문에 레이아웃 변화가 적은 경우에 적합합니다.
**-> 언제 Flex를 쓰고 언제 Grid를 쓸지에 대해 아는 것이 가장 중요!!**

### 18. **MVVM패턴과 Flux패턴의 차이점에 대해서 설명해보세요.**

MVVM은 데이터 바인딩을 사용하여 View와 ViewModel 간에 양방향 데이터 흐름을 유지합니다. 반면 Flux는 단방향 데이터 흐름을 사용하여 Action -> Dispatcher -> Store -> View의 방향으로 데이터가 흐릅니다. MVVM에서는 ViewModel이 Model의 역할을 수행하고, View와 ViewModel 사이에서 데이터를 중개합니다. 반면 Flux에서는 Store가 애플리케이션의 데이터와 비즈니스 로직을 담당하고, Dispatcher를 통해 Action을 처리합니다. Flux는 단방향 데이터 흐름과 단일 책임 원칙을 따르므로 테스트하기 쉬운 코드를 작성하기 쉽습니다. MVVM에서는 ViewModel과 View 간의 양방향 데이터 바인딩 때문에 테스트하기가 어려울 수 있습니다. MVVM은 Angular, Vue.js 등의 프레임워크에서 사용되며, Flux는 React에서 주로 사용됩니다.
**-> MVVM과 Flux가 각각 어떤 프레임워크에서 사용되는 패턴인지 아는 것**

### 19. **비동기 함수에 대해서 설명해 보세요.**

비동기 함수(Asynchronous function)는 함수의 실행 결과가 즉시 반환되지 않고, 특정 조건이 충족될 때까지 기다리는 함수입니다. 비동기 함수는 일반적으로 콜백 함수나 Promise 객체를 반환합니다. 콜백 함수는 비동기 작업이 완료되었을 때 호출되는 함수이며, Promise 객체는 비동기 작업이 성공적으로 완료되었는지 또는 실패했는지를 나타내는 객체입니다. 비동기 함수는 애플리케이션의 성능을 향상시키고, 사용자 인터페이스의 반응성을 유지하는 데 유용합니다. 그러나 비동기 함수를 사용할 때는 콜백 지옥과 같은 문제를 피하기 위해 적절한 에러 처리와 코드 구성이 필요합니다. 여러개의 비동기 함수가 실행되면, 이벤트 루프는 비동기 함수 호출을 처리하고, 비동기 함수가 완료되었을 때 콜백 함수를 호출합니다. 이벤트 루프는 실행 대기 중인 비동기 함수가 있으면 해당 함수를 호출하고, 실행이 완료될 때까지 다음 비동기 함수를 호출합니다. 따라서, 여러 개의 비동기 함수가 실행될 때 이들 함수는 동시에 실행되며, 이벤트 루프에 의해 비동기 함수의 실행 순서가 제어됩니다.
**-> 가장 중요한 질문이라고 생각되네요. 이벤트 루프에 대해서도 꼭 숙지하기!**

### 추가적인 개념

- Serverless
    
    **서버리스 아키텍처(Serverless Architecture)** 
    
    전통적인 서버를 직접 **구축, 운영하지 않고
    클라우드 서비스 제공자가 서버 관리**를 대신해주는 아키텍처
    
    **개발자는 오직 기능(코드)만 작성하고**, 나머지 인프라는 클라우드가 자동으로 처리
    
    | **항목** | **전통적 방식** | **서버리스 방식** |
    | --- | --- | --- |
    | 서버 유지 | 직접 설치 & 운영 | 클라우드가 관리 |
    | 비용 | 항상 실행 → 고정 비용 | 호출한 만큼만 과금 (페이퍼 유즈) |
    | 확장성 | 수동 설정 필요 | 자동 확장 (스케일링) |
    | 배포 | 앱 전체를 배포 | 함수 단위로 배포 |
    
    **구성요소**
    
    | **구성** | **설명** | **예시** |
    | --- | --- | --- |
    | **FaaS (Function as a Service)** | 함수 단위 코드 실행 | AWS Lambda, Vercel Functions, Cloud Functions |
    | **API Gateway** | HTTP 요청을 함수로 연결 | AWS API Gateway, Vercel Edge Functions |
    | **DB** | 서버리스 DB 사용 | Firebase, DynamoDB, PlanetScale |
    | **Storage** | 정적 파일 저장 | AWS S3, Firebase Storage |
    
    **프론트엔드 개발자 입장**
    
    - 백엔드 코드를 직접 짜지 않고도 기능 구현 가능!
    - Next.js + Vercel처럼 프론트와 백엔드가 같이 배포되는 환경에서 서버리스 함수로 API 구현 가능!
    
    **서버리스의 장점/단점** 
    
    | 장점 |  | 단점 |  |
    | --- | --- | --- | --- |
    | **비용 절감** | 사용한 만큼만 과금 (초 단위로) | **콜드 스타트** | 요청 없을 땐 함수가 ‘잠자기 상태’ → 느려질 수 있음 |
    | **빠른 배포** | 코드만 작성하면 바로 배포 가능 | **복잡한 로직** | 긴 실행 시간이나 복잡한 API는 부적합 |
    | **자동 확장성** | 요청 많아져도 자동으로 스케일링 | **디버깅 어려움** | 로컬에서 완전히 똑같이 재현하기 어려움 |
    | **운영 간소화** | 서버 유지/보수, OS 패치 불필요 | **벤더 락인** | 특정 클라우드 환경에 종속될 수 있음 (ex. AWS, Firebase 등) |
    
    **어디서 사용**
    
    | **분야** | **예시** |
    | --- | --- |
    | 백엔드 없는 웹앱 | 정적 페이지 + 서버리스 API |
    | 챗봇, 슬랙봇 | 이벤트 발생 시 함수 실행 |
    | 이미지 처리 | 업로드 후 썸네일 자동 생성 |
    | 실시간 알림 | 서버리스로 Firebase 알림 트리거 |
- 스타일 차이
    
    **1. CSS (Cascading Style Sheets)**
    
    우리가 가장 기본적으로 쓰는 스타일링 언어
    
    ```
    /* CSS 예시 */
    .button {
      color: white;
      background-color: blue;
      padding: 10px;
    }
    ```
    
    - 순수 스타일링 언어 (기능 없음)
    - 변수, 중첩, 믹스인 같은 **프로그래밍적 기능 X**
    - 간단하고 보편적이지만, **복잡한 UI에서는 비효율적**일 수 있음
    
    ---
    
    **2. Sass / Scss**
    
    CSS의 단점을 보완한 **전처리기(preprocessor)**
    
    더 효율적인 스타일링을 가능하게 해주는 도구
    Sass와 Scss는 “문법만 다르고” 기능은 같음!
    
    ---
    
    **1) SASS (Syntactically Awesome Style Sheets)**
    
    - **들여쓰기 기반** 문법
    - 중괄호 {}, 세미콜론 ; 없음
    - **파이썬 스타일**이라고 보면 됨
    
    ```
    // SASS 예시
    .button
      color: white
      background-color: blue
      padding: 10px
    ```
    
    ---
    
    **2) SCSS (Sassy CSS)**
    
    - **CSS와 거의 똑같은 문법**에 기능만 추가된 버전
    - 중괄호, 세미콜론 사용 O
    - 요즘은 대부분 SCSS를 선호함 (익숙함 + 호환성 좋음)
    
    ```
    // SCSS 예시
    $main-color: blue;
    
    .button {
      color: white;
      background-color: $main-color;
      padding: 10px;
    
      &:hover {
        background-color: darken($main-color, 10%);
      }
    }
    ```
    
    **차이**
    
    | **구분** | **CSS** | **Sass** | **SCSS** |
    | --- | --- | --- | --- |
    | 문법 | 기본 | 들여쓰기 기반 | CSS 유사 |
    | 기능 | 없음 | O | O |
    | 사용 난이도 | 쉬움 | 생소할 수 있음 | 쉬움 (CSS랑 비슷) |
    | 요즘 추세 | X | 거의 안 씀 | **많이 씀 (표준처럼 쓰임)** |
    
    **Tailwind CSS란?**
    
    **HTML에 클래스 이름만 붙여서** 빠르게 스타일링하는 방식
    
    UI 컴포넌트 라이브러리 느낌
    
    ```
    <button class="bg-indigo-600 hover:bg-indigo-700 text-white py-2 px-4 rounded">
      버튼
    </button>
    ```
    
    - 처음엔 클래스가 너무 많아져서 보기 불편할 수 있음
    - 하지만 **속도 빠르고 일관성 있는 디자인 유지**에 매우 유리함
    - 특히 팀/디자인 시스템 중심의 프로젝트에 강함
    
    **Styled Components란?**
    
    React에서 컴포넌트 단위로 **스타일을 작성할 수 있게 해주는 CSS-in-JS 라이브러리** 중 하나
    
    ```
    npm install styled-components
    ```
    
    - JS 파일 안에서 CSS를 바로 작성 가능
    - **스타일과 컴포넌트를 강하게 연결**시킴
    - 동적 스타일링 / props 기반 스타일링 편함
    - **TypeScript와도 잘 호환**
    
    ---
    
    **장점 / 단점**
    
    | **장점** |  | **단점** |  |
    | --- | --- | --- | --- |
    | **컴포넌트 기반** | 스타일도 컴포넌트처럼 관리 가능 | **빌드 성능 저하** | CSS-in-JS 특성상 컴파일 시간이 늘 수 있음 |
    | **동적 스타일링** | props, 상태 등에 따라 스타일 변경 가능 | **클래스 추적 어려움** | 실제 HTML에서는 난수 클래스명으로 보임 |
    | **스타일 중복 방지** | 각 스타일은 자동으로 고유 클래스 생성됨 | **자바스크립트에 익숙하지 않으면 진입장벽 ↑** |  |
    | **JS 문법 사용** | 조건문, 변수 등 자유롭게 활용 가능 |  |  |
    | **ThemeProvider** 지원 | 테마 설정해서 글로벌 스타일 구성 가능 |  |  |
    - 스타일을 **컴포넌트 단위로 명확히 관리**하고 싶을 때
    - **props 기반의 동적 스타일링**이 많은 프로젝트
    - CSS 파일 따로 관리하기 싫을 때
    - **디자인 시스템 구축** 시에 유리함
- SSG
    
    **Static Site Generation**의 줄임말로,
    
    **웹 페이지를 빌드 타임에 HTML로 미리 생성**해서 배포하는 방식입니다.
    
    서버가 아닌 **빌드할 때 HTML을 만들어두고**, 사용자가 접근하면 바로 그 HTML을 보여줍니다.
    
    **SSG vs SSR vs CSR** 
    
    | **방식** | **시점** | **특징** |
    | --- | --- | --- |
    | SSG | **빌드 시** | 가장 빠르고 정적 |
    | SSR | **요청 시 서버에서 생성** | 매번 새 HTML 생성 (실시간성 높음) |
    | CSR | **브라우저에서 JS로 그려짐** | 초반 로딩 느릴 수 있음, 완전히 프론트 중심 |
- SSG vs SSR vs CSR
    
    
    | **구분** | **의미** | **언제 HTML 생성?** | **특징** |
    | --- | --- | --- | --- |
    | **SSG** (Static Site Generation) | 정적 사이트 생성 | **빌드 타임** | 빠르고 SEO에 강함, 실시간성 ↓ |
    | **SSR** (Server Side Rendering) | 서버 사이드 렌더링 | **요청 시 서버에서 생성** | 실시간 데이터 가능, 성능 부담 ↑ |
    | **CSR** (Client Side Rendering) | 클라이언트 사이드 렌더링 | **브라우저에서 JS로 생성** | 초기 로딩 느림, 인터랙션 좋음 |
    
    **예시 비교 (사용자가 /profile 페이지 접속 시)**
    
    1. **SSG**
    - 빌드할 때 /profile 페이지의 HTML을 미리 생성해 둠
    - 사용자가 접근하면 → 이미 만들어진 HTML을 즉시 전달
    - 예: 블로그, 문서 사이트 등 자주 안 바뀌는 콘텐츠
    1. **SSR**
    - 사용자가 /profile 요청할 때마다 서버에서 HTML을 생성
    - 최신 데이터를 항상 반영 가능
    - 예: 로그인 후 사용자 맞춤 페이지
    1. **CSR**
    - /profile 접속 시, HTML은 거의 비어 있고 JS만 로딩됨
    - 브라우저가 JS를 실행해서 내용을 동적으로 그림
    - 예: SPA (Single Page Application) 전형적 방식
    
    | **항목** | **속도** | **실시간성** | **SEO** | **서버 부담** |
    | --- | --- | --- | --- | --- |
    | **SSG** | 매우 빠름 | 낮음 | 좋음 | 낮음 |
    | **SSR** | 중간 | 높음 | 좋음 | 높음 |
    | **CSR** | 느릴 수 있음 | 높음 | 나쁨 (추가 설정 필요) | 낮음 |
    
    | **사용 사례** | **추천 방식** |
    | --- | --- |
    | 블로그, 문서 페이지 | SSG |
    | 사용자별 데이터 페이지 | SSR |
    | 대시보드, SPA 앱 | CSR |
    | 하이브리드 | SSG + CSR or SSR + CSR 조합 |
- 바인딩
    
    **바인딩이란?**
    
    **“어떤 값을 특정 변수나 함수에 연결하는 것”**
    
    바인딩은 **언제**, **어디서**, **무엇이** 연결되는지를 설명할 때 
    
    주로 **this 바인딩**, **이벤트 바인딩**, **데이터 바인딩** 등의 맥락에서 쓰입니다
    
    1.  **this 바인딩 (JavaScript에서 제일 자주 나옴)**
    
    ```
    const obj = {
      name: "Yong",
      sayHi() {
        console.log(this.name);
      }
    };
    obj.sayHi(); // "Yong"
    ```
    
    이 경우 this는 obj를 바인딩하고 있어요.
    
    하지만 함수만 따로 떼내면…
    
    ```
    const say = obj.sayHi;
    say(); // undefined (this가 window 또는 undefined를 가리킴)
    ```
    
    이럴 땐 bind로 수동 바인딩 필요!
    
    ```
    const boundSay = obj.sayHi.bind(obj);
    boundSay(); // "Yong"
    ```
    
    1. **이벤트 바인딩**
    
    ```
    button.addEventListener('click', handleClick);
    ```
    
    클릭 이벤트와 handleClick 함수가 **바인딩**된 상태
    
    1. **데이터 바인딩 (프론트엔드 프레임워크에서 많이 씀)**
    - **단방향 바인딩**: 데이터가 UI에만 반영됨 (React)
    - **양방향 바인딩**: 데이터와 UI가 서로 반영됨 (Vue, Angular)
    
    ```
    // React 예시 (단방향 바인딩)
    <input value={text} onChange={e => setText(e.target.value)} />
    ```
    
    | this 바인딩 | 함수 호출 맥락에 따라 this가 가리키는 객체가 달라짐 |
    | --- | --- |
    | bind() | 함수의 this를 강제로 바인딩 |
    | 이벤트 바인딩 | DOM 이벤트와 함수 연결 |
    | 데이터 바인딩 | 상태(state)와 UI 연결 (단방향 / 양방향) |
    
    **바인딩은 “무언가를 연결하는 행위”**로, this, 이벤트, 상태 등 다양한 곳에서 등장합니다!